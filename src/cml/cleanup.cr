# CML Cleanup Registry
# Implements SML/NJ CML_CLEANUP signature for logging channels, mailboxes, and servers
# for initialization and termination cleanup.
module CML
  module Cleanup
    # When to run clean-up routines
    enum When
      # Initialization of a program under RunCML.doit (not used in Crystal)
      AtInit
      # Initialization of a stand-alone program generated by exportFn (not used)
      AtInitFn
      # Normal program exit of a CML program running under RunCML.doit
      AtShutdown
      # Normal program exit of a stand-alone CML program
      AtExit
    end

    # All times (for convenience)
    AT_ALL = [When::AtExit, When::AtShutdown, When::AtInit, When::AtInitFn]

    # Hook entry: name, list of When, cleanup function
    private class Hook
      getter name : String
      getter whens : Array(When)
      getter cleaner : When -> Nil

      def initialize(@name, @whens, @cleaner)
      end
    end

    # Item entry for channels, mailboxes, servers
    private class Item
      getter name : String
      getter init : -> Nil
      getter shut : -> Nil

      def initialize(@name, @init, @shut)
      end
    end

    @@hooks = [] of Hook
    @@chan_items = [] of Item
    @@mbox_items = [] of Item
    @@server_items = [] of Item
    @@mutex = Sync::Mutex.new(:reentrant)

    # Protect a block with mutex if CML is running
    private def self.protect(&block : -> T) : T forall T
      if CML.running?
        @@mutex.synchronize do
          block.call
        end
      else
        block.call
      end
    end

    # ----------------------------------------------------------------------
    # Generic cleaners API
    # ----------------------------------------------------------------------

    # Add a named cleaner
    def self.add_cleaner(name : String, whens : Array(When), cleaner : When -> Nil) : Nil
      protect do
        # remove existing with same name
        @@hooks.reject! { |h| h.name == name }
        @@hooks << Hook.new(name, whens, cleaner)
      end
    end

    # Remove a named cleaner
    def self.remove_cleaner(name : String) : Bool
      protect do
        before = @@hooks.size
        @@hooks.reject! { |h| h.name == name }
        before != @@hooks.size
      end
    end

    # Run cleaners for a specific When
    def self.clean(time : When) : Nil
      protect do
        filtered = @@hooks.select(&.whens.includes?(time))
        # reverse order for initialization times
        list = case time
               when When::AtInit, When::AtInitFn
                 filtered.reverse
               else
                 filtered
               end
        list.each do |hook|
          # run cleaner in a spawn with timeout? (as in SML)
          spawn do
            hook.cleaner.call(time)
          end
        end
      end
    end

    # ----------------------------------------------------------------------
    # Channel logging
    # ----------------------------------------------------------------------

    # Log a channel with a given name
    def self.log_channel(name : String, chan : Chan(T)) forall T
      protect do
        unlog_channel(name) rescue nil
        item = Item.new(name, -> { chan.reset }, -> { chan.reset })
        @@chan_items << item
      end
    end

    # Unlog a channel by name
    def self.unlog_channel(name : String) : Bool
      protect do
        before = @@chan_items.size
        @@chan_items.reject! { |item| item.name == name }
        before != @@chan_items.size
      end
    end

    # ----------------------------------------------------------------------
    # Mailbox logging
    # ----------------------------------------------------------------------

    # Log a mailbox with a given name
    def self.log_mailbox(name : String, mbox : Mailbox(T)) forall T
      protect do
        unlog_mailbox(name) rescue nil
        item = Item.new(name, -> { mbox.reset }, -> { mbox.reset })
        @@mbox_items << item
      end
    end

    # Unlog a mailbox by name
    def self.unlog_mailbox(name : String) : Bool
      protect do
        before = @@mbox_items.size
        @@mbox_items.reject! { |item| item.name == name }
        before != @@mbox_items.size
      end
    end

    # ----------------------------------------------------------------------
    # Server logging
    # ----------------------------------------------------------------------

    # Log a server with init and shutdown procs
    def self.log_server(name : String, init : -> Nil, shut : -> Nil) : Nil
      protect do
        unlog_server(name) rescue nil
        @@server_items << Item.new(name, init, shut)
      end
    end

    # Unlog a server by name
    def self.unlog_server(name : String) : Bool
      protect do
        before = @@server_items.size
        @@server_items.reject! { |item| item.name == name }
        before != @@server_items.size
      end
    end

    # ----------------------------------------------------------------------
    # Cleanup actions
    # ----------------------------------------------------------------------

    # Unlog all items
    def self.unlog_all : Nil
      protect do
        @@chan_items.clear
        @@mbox_items.clear
        @@server_items.clear
      end
    end

    # Initialize all logged servers (call init procs)
    private def self.start_servers : Nil
      @@server_items.reverse_each do |item|
        item.init.call
      end
    end

    # Shutdown all logged servers (call shut procs)
    private def self.shutdown_servers : Nil
      @@server_items.each do |item|
        item.shut.call
      end
    end

    # Clean channels and mailboxes (call init procs)
    private def self.clean_channels : Nil
      (@@chan_items + @@mbox_items).reverse_each do |item|
        item.init.call
      end
    end

    # Clean servers based on When
    private def self.clean_servers(time : When) : Nil
      case time
      when When::AtInit, When::AtInitFn
        start_servers
      when When::AtShutdown, When::AtExit
        shutdown_servers
      end
    end

    # Standard cleaners (as in SML)
    private def self.chan_cleaner(time : When) : Nil
      clean_channels
    end

    private def self.serv_cleaner(time : When) : Nil
      clean_servers(time)
    end

    # Register standard cleaners (call this during CML initialization)
    def self.register_standard_cleaners : Nil
      add_cleaner("Channels&Mailboxes", [When::AtInit, When::AtShutdown], ->(time : When) { chan_cleaner(time) })
      add_cleaner("Servers", AT_ALL, ->(time : When) { serv_cleaner(time) })
    end

    # ----------------------------------------------------------------------
    # Public API matching SML/NJ CML_CLEANUP signature
    # ----------------------------------------------------------------------

    # Returns list of all When values
    def self.at_all : Array(When)
      AT_ALL
    end

    # Add cleaner with previous definition returned (SML style)
    def self.add_cleaner_with_previous(name : String, whens : Array(When), cleaner : When -> Nil)
      protect do
        prev = @@hooks.find { |h| h.name == name }
        if prev
          @@hooks.delete(prev)
          @@hooks << Hook.new(name, whens, cleaner)
          {prev.whens, prev.cleaner}
        else
          @@hooks << Hook.new(name, whens, cleaner)
          nil
        end
      end
    end

    # Remove cleaner and return previous definition (SML style)
    def self.remove_cleaner_with_previous(name : String)
      protect do
        prev = @@hooks.find { |h| h.name == name }
        if prev
          @@hooks.delete(prev)
          {prev.whens, prev.cleaner}
        end
      end
    end

    # Exception raised when unlog fails
    class Unlog < Exception; end

    # Log channel (SML style, raises Unlog on duplicate?)
    def self.log_channel(name : String, chan : Chan(T), raise_on_duplicate : Bool = false) forall T
      protect do
        if raise_on_duplicate && @@chan_items.any? { |item| item.name == name }
          raise Unlog.new("Channel already logged: #{name}")
        end
        unlog_channel(name) rescue nil
        @@chan_items << Item.new(name, -> { chan.reset }, -> { chan.reset })
      end
    end

    # Similar for mailbox and server

    # Clean all registered items for a given When (call this at appropriate times)
    def self.clean_all(time : When) : Nil
      clean(time)
      case time
      when When::AtInit, When::AtInitFn
        clean_channels
        start_servers
      when When::AtShutdown, When::AtExit
        clean_channels
        shutdown_servers
      end
    end

    # Convenience: clean at program exit
    def self.at_exit_cleanup : Nil
      clean_all(When::AtExit)
    end

    # Setup at_exit hook (call once)
    def self.setup_at_exit_hook
      at_exit { at_exit_cleanup }
    end
  end
end

# Register standard cleaners when module loads
CML::Cleanup.register_standard_cleaners
CML::Cleanup.setup_at_exit_hook
